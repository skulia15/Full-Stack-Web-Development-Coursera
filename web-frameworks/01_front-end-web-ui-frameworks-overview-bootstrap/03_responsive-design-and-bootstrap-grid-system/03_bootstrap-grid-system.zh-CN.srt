1
00:00:04,420 --> 00:00:07,980
在响应式设计的讨论中

2
00:00:07,980 --> 00:00:13,471
我们提到过网格系统

3
00:00:13,471 --> 00:00:19,030
我说过 许多前端 UI 框架都支持
一定形式的网格系统

4
00:00:19,030 --> 00:00:23,030
而 Bootstrap 支持的网格系统
就叫 Bootstrap 网格系统

5
00:00:23,030 --> 00:00:28,118
在这节课里 我们将详细地
学习 Bootstrap 网格系统

6
00:00:28,118 --> 00:00:33,100
并了解如何应用 Bootstrap 网格系统

7
00:00:33,100 --> 00:00:38,412
来设计响应式网站

8
00:00:39,670 --> 00:00:44,070
当我们配置网页项目以使用 Bootstrap 时

9
00:00:44,070 --> 00:00:50,040
首先需要加入 HTML 的是设置了

10
00:00:50,040 --> 00:00:55,800
name="viewport" 的 meta 标签

11
00:00:55,800 --> 00:01:03,000
这个标签将使我们的网页
能够识别设备的宽度

12
00:01:03,000 --> 00:01:07,580
从而能让我们的网页
进行相应的调整以适应设备

13
00:01:07,580 --> 00:01:10,870
在这个栗子里 我还设置了
content="width=device-width"

14
00:01:10,870 --> 00:01:16,260
这意味着我将我们的页面宽度
设置为了和移动设备的宽度一样

15
00:01:16,260 --> 00:01:21,750
也就是说无论我们用什么移动设备
来浏览我们的网页

16
00:01:21,750 --> 00:01:26,880
我们的网页都能占据那个
移动设备的整个屏幕

17
00:01:26,880 --> 00:01:31,280
比如 如果通过手机或平板电脑
访问我们的页面的话

18
00:01:31,280 --> 00:01:38,500
我们的页面将会相应地占据
我们所用的手机或平板的屏幕

19
00:01:39,840 --> 00:01:44,730
对于笔记本和台式电脑
由于浏览器的窗口

20
00:01:44,730 --> 00:01:49,450
可以调整得任意小

21
00:01:49,450 --> 00:01:53,910
所以浏览器的窗口可以小于
任一移动设备的尺寸

22
00:01:53,910 --> 00:01:59,180
此时 device-width 这项属性将会设置成

23
00:01:59,180 --> 00:02:04,560
当前浏览器窗口的宽度

24
00:02:06,200 --> 00:02:12,820
所以设置了 viewport 的 meta 标签
可以用于识别和设置 device-width

25
00:02:12,820 --> 00:02:17,000
从而能使我们网页的内容以
正确的宽度来渲染

26
00:02:18,160 --> 00:02:22,590
而若想设计对 viewport【视口】
尺寸响应的网站

27
00:02:22,590 --> 00:02:26,100
我们就需要使用网格系统

28
00:02:26,100 --> 00:02:29,430
而对我们来说 要用的就是
Bootstrap 网格系统

29
00:02:29,430 --> 00:02:32,860
我们接下来会进行更详细的介绍

30
00:02:33,920 --> 00:02:37,276
Bootstrap 网格系统本身就是一套

31
00:02:37,276 --> 00:02:41,620
响应式的 移动设备优先的
流式栅格系统

32
00:02:41,620 --> 00:02:44,170
这些特性使我们能够

33
00:02:44,170 --> 00:02:48,120
使用 Bootstrap 网格系统来
设计响应式网站

34
00:02:48,120 --> 00:02:54,580
我们马上就会学习如何使用它

35
00:02:54,580 --> 00:02:59,470
然后在那之后

36
00:02:59,470 --> 00:03:01,240
我们会用一个练习以
对之进行更详细地学习

37
00:03:02,400 --> 00:03:07,050
在之前的练习和讨论中

38
00:03:07,050 --> 00:03:11,340
我们已经了解了 Bootstrap 中的
container 这个东西了

39
00:03:12,530 --> 00:03:19,210
container 类用来封装网页中的内容

40
00:03:19,210 --> 00:03:25,260
它让我们能够定义屏幕渲染时

41
00:03:25,260 --> 00:03:30,410
内容在网页中所占的宽度

42
00:03:31,460 --> 00:03:37,770
总之 当你定义好这个 meta 后

43
00:03:37,770 --> 00:03:44,050
你的 container 就能够基于屏幕大小

44
00:03:44,050 --> 00:03:50,040
来调整它自己的大小了

45
00:03:50,040 --> 00:03:56,020
然后在 container 里面
会分成若干的 row

46
00:03:57,210 --> 00:04:01,999
row 这个东西会占满整个 container

47
00:04:03,100 --> 00:04:08,360
如图所示

48
00:04:08,360 --> 00:04:09,950
然后在每个 row 里面

49
00:04:11,890 --> 00:04:19,730
又会有 12 个等分的 col

50
00:04:19,730 --> 00:04:24,080
而这就是 Bootstrap 的网格系统了

51
00:04:24,080 --> 00:04:29,090
当你把东西放在这个网格系统中时
你可以让它占据一行 12 个 column 中的

52
00:04:29,090 --> 00:04:33,340
任意多个 column

53
00:04:33,340 --> 00:04:38,220
比如说

54
00:04:39,530 --> 00:04:44,310
你可以让一个东西

55
00:04:44,310 --> 00:04:49,390
占据这一行的前七个 column
也就是前七列

56
00:04:49,390 --> 00:04:53,840
如图所示则是占据了前五列

57
00:04:53,840 --> 00:04:57,403
我用了 class="col-sm-5"

58
00:04:57,403 --> 00:05:01,260
这个类及同一系列类的具体用法
我会在后面进行详细说明

59
00:05:01,260 --> 00:05:05,610
不过从直观上来说
那个 col 和 5 都是

60
00:05:05,610 --> 00:05:07,570
比较好理解的

61
00:05:07,570 --> 00:05:11,330
然后如果我想让另一个东西

62
00:05:11,330 --> 00:05:13,310
占据剩下 7 列的时候

63
00:05:13,310 --> 00:05:13,920
我再用 class="col-sm-7" 即可

64
00:05:13,920 --> 00:05:18,330
做完这些后 你可以看到
这两个东西并排地靠在一起

65
00:05:20,040 --> 00:05:24,670
不过它们之间还是
有一个小小的间隙

66
00:05:24,670 --> 00:05:25,740
我们管那个叫 gutter

67
00:05:27,070 --> 00:05:32,380
对于应用 Bootstrap 网格系统的细节

68
00:05:33,530 --> 00:05:34,950
我们接下来就会说明

69
00:05:37,710 --> 00:05:43,420
首先要明确的是
Bootstrap 从总体上而言

70
00:05:43,420 --> 00:05:48,190
有四个"类"特别重要
它们对应着四种不同的屏幕大小

71
00:05:48,190 --> 00:05:54,050
其一为 xs, 也就是 extra small【"超小"】
这一"类"通常用于手机

72
00:05:54,050 --> 00:05:57,820
其二为 sm, 也就是 small【"小"】

73
00:05:57,820 --> 00:06:01,670
它一般用于屏幕大小大概在
手机屏幕大小和笔记本电脑屏幕大小之间

74
00:06:01,670 --> 00:06:04,450
的那些设备上

75
00:06:04,450 --> 00:06:13,530
其三为 md, 也就是 medium【"中等大小"】
一般就用于笔记本电脑的感觉

76
00:06:13,530 --> 00:06:17,890
其四为 lg, 也就是 large 了【"大"】
顾名思义 就是用在大屏幕上的

77
00:06:17,890 --> 00:06:21,440
如果要定量的话 就是屏幕宽度
大于 1200 像素的屏幕

78
00:06:23,570 --> 00:06:32,138
这四种"类"会和其它的类组合起来使用
使用的场合在刚刚进行了说明

79
00:06:32,138 --> 00:06:36,033
所以我猜你现在知道 col-sm-5 之类的
是什么意思了

80
00:06:36,033 --> 00:06:40,580
就是当屏幕大小处于 sm 时
这个东西将占领 5 个 column

81
00:06:40,580 --> 00:06:45,370
col-xs-*, col-md-*, col-lg-*
等等等等

82
00:06:45,370 --> 00:06:46,710
都是同理的

83
00:06:48,350 --> 00:06:53,280
其中 * 处要用一个小于 12 的数字代替
以表明这个东西在特定的屏幕大小下

84
00:06:53,280 --> 00:06:58,290
将占据 12 列中的多少列

85
00:06:58,290 --> 00:07:01,550
比如如果我对同一个东西
同时设置了

86
00:07:01,550 --> 00:07:06,580
col-xs-12 和 col-sm-5 的话

87
00:07:06,580 --> 00:07:12,470
意味着在 xs 的屏幕大小下
这个东西将占据所有 12 列

88
00:07:13,970 --> 00:07:21,730
而在 sm 的屏幕大小下
就只占据 5 列

89
00:07:21,730 --> 00:07:27,110
这里有张表格可以让你了解到
这四个"类"的一些细节

90
00:07:27,110 --> 00:07:31,530
其中 xs 代表着任何屏幕宽度小于
768 像素的屏幕

91
00:07:31,530 --> 00:07:36,640
sm 则是 768 ~ 992

92
00:07:36,640 --> 00:07:40,870
md 为 992 ~ 1200

93
00:07:40,870 --> 00:07:44,840
lg 则代表着任何屏幕宽度
大于 1200 像素的屏幕

94
00:07:44,840 --> 00:07:49,650
显然 每一个屏幕都会归属到

95
00:07:49,650 --> 00:07:50,520
这四个"类"中的一个

96
00:07:51,600 --> 00:07:55,860
然后来看看 Grid behavior【"排列行为"】

97
00:07:55,860 --> 00:08:01,760
在 xs 下 所有东西都是

98
00:08:03,460 --> 00:08:08,692
竖着一直排下来的

99
00:08:08,692 --> 00:08:13,270
当然 每个 row 里面 column的行为
是不会改变的

100
00:08:13,270 --> 00:08:18,760
而从 sm 开始 有些在 xs 里面
被折叠的内容就会展开

101
00:08:18,760 --> 00:08:24,282
你可以通过指定

102
00:08:24,282 --> 00:08:26,330
合适的 column 类来定制这些内容

103
00:08:26,330 --> 00:08:30,690
container 在不同的屏幕大小下

104
00:08:30,690 --> 00:08:34,740
也有着不同的表现

105
00:08:34,740 --> 00:08:38,250
在 sm 屏幕大小下 container 的宽度

106
00:08:38,250 --> 00:08:43,240
将会一直是 750 像素
在 lg 屏幕 则将会一直是 1170 像素

107
00:08:43,240 --> 00:08:50,410
不要忘了 lg 是指屏幕宽度
不小于 1200 像素的屏幕

108
00:08:53,160 --> 00:08:58,550
不过无论 container 的
实际宽度为多少

109
00:08:58,550 --> 00:09:02,990
其内部的每个 row 都是等分成
12 个 column 的

110
00:09:04,970 --> 00:09:09,770
而对于 gutter, 也就是每个 row 中

111
00:09:09,770 --> 00:09:12,970
相邻两块内容之间的那个空隙

112
00:09:12,970 --> 00:09:16,140
将总会是 30 像素

113
00:09:16,140 --> 00:09:19,680
比如如果你现在在一个 row 里面
放了两块内容 A 和 B

114
00:09:19,680 --> 00:09:23,930
其中 A 占了 5 列而 B 占了 7列

115
00:09:23,930 --> 00:09:28,470
那么在 A 和 B 之间就会有一个
30 像素大小的空隙

116
00:09:28,470 --> 00:09:32,860
这个空隙就叫 gutter
这样一来, A 和 B 两块内容就能

117
00:09:32,860 --> 00:09:36,636
比较清晰地区分开彼此

118
00:09:38,490 --> 00:09:44,730
对于 column 的宽度 则是基于
当前屏幕宽度计算得到的

119
00:09:44,730 --> 00:09:48,393
比如说对于 sm 屏幕

120
00:09:48,393 --> 00:09:52,130
每一列会大概占 62 像素
而对于 lg 屏幕的话

121
00:09:52,130 --> 00:09:56,405
则会大概占 97 像素

122
00:09:58,528 --> 00:10:03,143
而正如我提到过的 我们可以针对
不同的屏幕大小来

123
00:10:03,143 --> 00:10:09,260
定制不同的排列样式

124
00:10:09,260 --> 00:10:13,470
现在我们展示的这个栗子里

125
00:10:13,470 --> 00:10:16,870
我们对两块内容 A 和 B 进行了一些设置
以使它们在 xs 大小下

126
00:10:16,870 --> 00:10:21,570
将会上下排列 同时在 sm 屏幕
或更大的屏幕下时 将会左右排列

127
00:10:22,830 --> 00:10:26,715
我是通过对 A 和 B 分别设置了

128
00:10:26,715 --> 00:10:31,350
class="col-xs-12" 以使它们在
xs 屏幕下能够上下排列

129
00:10:31,350 --> 00:10:34,540
而如果此时我想让它们在

130
00:10:34,540 --> 00:10:39,870
sm 或更大的屏幕下

131
00:10:39,870 --> 00:10:45,550
像右边这张图这样左右排列的话

132
00:10:45,550 --> 00:10:51,680
只需再对 A 设置 col-sm-5

133
00:10:51,680 --> 00:10:56,950
和对 B 设置 col-sm-7 即可

134
00:10:56,950 --> 00:11:00,200
其中 sm-5 意味着 A 将会在
sm 屏幕下占据 5 个 column

135
00:11:00,200 --> 00:11:04,560
sm-7 则意味着 B 将会在 sm 屏幕下

136
00:11:04,560 --> 00:11:06,140
占据 7 个 column

137
00:11:06,140 --> 00:11:11,160
这样一来 在 sm 屏幕下
A 和 B 就会左右排列了

138
00:11:11,160 --> 00:11:15,130
由于我们没有再设置 md 和 lg 的类

139
00:11:15,130 --> 00:11:21,280
所以在 md 和 lg 屏幕下
Bootstrap 将会沿用我们对

140
00:11:21,280 --> 00:11:25,925
sm 屏幕的设置

141
00:11:25,925 --> 00:11:31,024
事实上对于 Bootstrap 的某些属性
如果没有显式设置大屏幕下的表现的话

142
00:11:31,024 --> 00:11:36,871
Bootstrap 会自动把你对小屏幕的设置
应用到那些大屏幕上

143
00:11:36,871 --> 00:11:41,660
在这个栗子里我对 A 设置了 col-sm-5
但没有设置 col-md 和 col-lg

144
00:11:41,660 --> 00:11:45,609
那么 Bootstrap 就会根据我的 col-sm-5
帮我设置好 col-md-5 和 col-lg-5

145
00:11:45,609 --> 00:11:50,229
意味着只要在不小于 sm 的屏幕下
A 都会占据 5 个 column

146
00:11:50,229 --> 00:11:54,920
对 B 也是同理的

147
00:11:54,920 --> 00:11:59,000
这是 Bootstrap 的内置功能

148
00:11:59,000 --> 00:12:01,920
能让你免于重复做某些相同的设置

149
00:12:03,850 --> 00:12:09,815
Bootstrap 还提供了一个系列的类

150
00:12:09,815 --> 00:12:11,345
叫 pull 和 push

151
00:12:11,345 --> 00:12:12,135
应用 pull 和 push 类的话

152
00:12:12,135 --> 00:12:17,610
你就能把网页中的一些内容
"拉回来"或"推出去"了

153
00:12:17,610 --> 00:12:23,210
那么这里有一个栗子
你可以看到 A 和 B 两块内容

154
00:12:23,210 --> 00:12:29,460
在 xs 屏幕下仍然是上下排列的

155
00:12:29,460 --> 00:12:31,730
A 在上 B 在下

156
00:12:32,810 --> 00:12:37,550
不过在 sm 或更大的屏幕下

157
00:12:37,550 --> 00:12:40,720
你可以看到 与之前不同的是
虽然它们仍是左右排列

158
00:12:40,720 --> 00:12:44,880
但 B 跑到左边而 A 跑到右边了
这是因为应用了 push 和 pull

159
00:12:44,880 --> 00:12:48,210
你可以看到对于 A 而言
我为其额外设置了

160
00:12:48,210 --> 00:12:53,120
col-sm-push-7

161
00:12:53,120 --> 00:12:58,510
意味着 A 将会被"推出去" 7 列

162
00:12:58,510 --> 00:13:03,290
也就是意味着 A 将会
占据这个 row 的后 5 个 column

163
00:13:03,290 --> 00:13:10,720
对于 B 我除了 col-sm-7 以外
还设置了 col-sm-pull-5

164
00:13:10,720 --> 00:13:16,200
意味着 B 将会被"拉回来" 5 列
也就是占据这个 row 的前 7 个 column

165
00:13:16,200 --> 00:13:20,704
所以有了 push 和 pull 之后

166
00:13:20,704 --> 00:13:24,720
你就能更灵活地定制网页的样式了

167
00:13:26,846 --> 00:13:30,444
Bootstrap 还有一个很好的类

168
00:13:30,444 --> 00:13:34,910
叫 offset

169
00:13:34,910 --> 00:13:39,960
它允许你"空出"一定的 column 出来

170
00:13:39,960 --> 00:13:43,970
在这个栗子里 我对一块内容

171
00:13:43,970 --> 00:13:46,890
设置了 col-sm-offset-1

172
00:13:47,900 --> 00:13:52,270
这意味着在 sm 或更大的屏幕下
这块内容将会在其前面

173
00:13:52,270 --> 00:13:56,360
"空出" 1 个 column 出来

174
00:13:56,360 --> 00:13:59,210
也就是从第 2 个 column 开始排版
而不是从第 1 个

175
00:13:59,210 --> 00:14:02,090
如果你不设置 offset 的话

176
00:14:02,090 --> 00:14:07,900
Bootstrap 会默认你从
第 1 个 column 开始排版

177
00:14:07,900 --> 00:14:12,336
在这个栗子里如果你在后面
跟一个 col-sm-7 的话 那么 col-sm-7

178
00:14:12,336 --> 00:14:13,822
 将会占据剩余的 7 个 column

179
00:14:16,550 --> 00:14:25,410
接下来我们要看的是"嵌套"的使用

180
00:14:25,410 --> 00:14:27,840
也就是说 我们完全可以在 row 里面
再用一个 row

181
00:14:28,900 --> 00:14:32,970
如图所示 我就在右边的 col-sm-7 里面

182
00:14:32,970 --> 00:14:38,870
插入了一个 row
然后在这个 row 里面

183
00:14:38,870 --> 00:14:43,400
我又能类似地加进一些内容

184
00:14:43,400 --> 00:14:47,100
对这些内容我能通过
一些 col 的类来定制它们

185
00:14:47,100 --> 00:14:51,565
那么对这个栗子 让我来叙述一下
它的层次结构

186
00:14:51,565 --> 00:14:56,445
首先是一个 container, 然后是一个 row
在这个 row 里面

187
00:14:56,445 --> 00:15:00,525
我插入了两块内容 它们分别设置了
col-sm-5 和 sol-sm-7

188
00:15:00,525 --> 00:15:04,850
然后在 col-sm-7 里面
我插入了另一个 row

189
00:15:04,850 --> 00:15:10,400
对于这个 row, Bootstrap 同样会

190
00:15:11,590 --> 00:15:17,460
在里面给我安排 12 个 column

191
00:15:17,460 --> 00:15:23,770
这 12 个 column 是在原先的
7 个 column 的空间中进行等分的

192
00:15:23,770 --> 00:15:28,960
然后你就可以

193
00:15:28,960 --> 00:15:34,030
利用这 12 个等分的 column
来类似地对你网页中的内容

194
00:15:34,030 --> 00:15:39,470
进行恰当的排版了

195
00:15:39,470 --> 00:15:44,170
这种嵌套的行为将能让你以

196
00:15:44,170 --> 00:15:48,989
更灵活的方式来在不同的屏幕大小下
对网页的各种不同内容进行排版

197
00:15:50,570 --> 00:15:55,990
以上 我们学习了如何利用
Bootstrap 的网格系统

198
00:15:55,990 --> 00:15:59,900
在不同的屏幕大小下

199
00:15:59,900 --> 00:16:05,220
对网页的各种内容
进行灵活的排版

200
00:16:06,690 --> 00:16:11,520
所以接下来我们将会
进行一个练习

201
00:16:11,520 --> 00:16:16,500
在这个练习里 我们会

202
00:16:16,500 --> 00:16:22,940
利用 Bootstrap 的网格系统

203
00:16:22,940 --> 00:16:26,469
来修改我们的网页

204
00:16:28,680 --> 00:16:34,310
从而使其能更好地
展示我们网页的内容

205
00:16:34,310 --> 00:16:39,210
特别的 我们还将学习如何
通过我们自己写的 CSS 代码

206
00:16:39,210 --> 00:16:43,921
来定制我们的网页
【翻译 - Carefree0910】